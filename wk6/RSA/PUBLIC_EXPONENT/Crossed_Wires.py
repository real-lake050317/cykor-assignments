#!/usr/bin/env python3
import random, math
from functools import reduce
from Crypto.Util.number import long_to_bytes

n = 21711308225346315542706844618441565741046498277716979943478360598053144971379956916575370343448988601905854572029635846626259487297950305231661109855854947494209135205589258643517961521594924368498672064293208230802441077390193682958095111922082677813175804775628884377724377647428385841831277059274172982280545237765559969228707506857561215268491024097063920337721783673060530181637161577401589126558556182546896783307370517275046522704047385786111489447064794210010802761708615907245523492585896286374996088089317826162798278528296206977900274431829829206103227171839270887476436899494428371323874689055690729986771

d = 2734411677251148030723138005716109733838866545375527602018255159319631026653190783670493107936401603981429171880504360560494771017246468702902647370954220312452541342858747590576273775107870450853533717116684326976263006435733382045807971890762018747729574021057430331778033982359184838159747331236538501849965329264774927607570410347019418407451937875684373454982306923178403161216817237890962651214718831954215200637651103907209347900857824722653217179548148145687181377220544864521808230122730967452981435355334932104265488075777638608041325256776275200067541533022527964743478554948792578057708522350812154888097

cipher = 20304610279578186738172766224224793119885071262464464448863461184092225736054747976985179673905441502689126216282897704508745403799054734121583968853999791604281615154100736259131453424385364324630229671185343778172807262640709301838274824603101692485662726226902121105591137437331463201881264245562214012160875177167442010952439360623396658974413900469093836794752270399520074596329058725874834082188697377597949405779039139194196065364426213208345461407030771089787529200057105746584493554722790592530472869581310117300343461207750821737840042745530876391793484035024644475535353227851321505537398888106855012746117

exponents = [106979, 108533, 69557, 97117, 103231]
e = 65537

# 1. Recover p, q from (n, d_known, e_ours)  — classical “decrypt-and-factor” trick
k = e * d - 1
s, t = 0, k
while t % 2 == 0:
    t //= 2
    s += 1

def factor_from_private():
    for _ in range(100):                            # 100 random bases is plenty
        g = random.randrange(2, n - 1)
        x = pow(g, t, n)
        if x in (1, n - 1):
            continue
        for _ in range(s - 1):
            y = pow(x, 2, n)
            if y == 1:
                p = math.gcd(x - 1, n)
                if 1 < p < n:
                    return p, n // p
            if y == n - 1:
                break
            x = y
    raise ValueError("Failed to factor n — try more bases")

p = 134460556242811604004061671529264401215233974442536870999694816691450423689575549530215841622090861571494882591368883283016107051686642467260643894947947473532769025695530343815260424314855023688439603651834585971233941772580950216838838690315383700689885536546289584980534945897919914730948196240662991266027
q = 161469718942256895682124261315253003309512855995894840701317251772156087404025170146631429756064534716206164807382734456438092732743677793224010769460318383691408352089793973150914149255603969984103815563896440419666191368964699279209687091969164697704779792586727943470780308857107052647197945528236341228473
phi_n  = (p - 1) * (q - 1)

# 2. Combine the five public exponents into a single exponent E
E = reduce(lambda a, b: (a * b) % phi, exponents, 1)

# 3. Find its modular inverse D  (so that E·D ≡ 1 mod φ(n))
D = pow(E, -1, phi)

# 4. Decrypt in one shot
m = pow(cipher, D, n)
flag = m.to_bytes((m.bit_length() + 7) // 8, 'big').decode()

print("Flag:", flag)
